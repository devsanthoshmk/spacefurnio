<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spacefurnio</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        brandPrimary: '#e67e22',
                        brandSecondary: '#2c3e50',
                        brandLight: '#fffdf6'
                    }
                }
            }
        }
    </script>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@600;700&display=swap" rel="stylesheet" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
    <link href="https://unpkg.com/aos@2.3.1/dist/aos.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;600&display=swap" rel="stylesheet">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Ms+Madi&display=swap" rel="stylesheet">

    <style>
        /* Products Section Styles */
        .products-section {
            position: relative;
            min-height: 600vh;
            background: linear-gradient(135deg, #fffdf6 0%, #f8f6f0 100%);
        }

        .products-grid {
            position: sticky;
            top: 0;
            height: 100vh;
            margin: 0 auto;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            overflow: hidden;
        }

        /* Dual layer system for smooth transitions */
        .bg-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            transition: all 1.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .bg-layer.current {
            opacity: 1;
            filter: blur(0px);
            transform: scale(1);
        }

        .bg-layer.blurred {
            filter: blur(15px) brightness(0.7);
            transform: scale(1.05);
        }

        .bg-layer.next {
            opacity: 0;
            filter: blur(0px);
            transform: scale(1.1);
        }

        .bg-layer.transitioning-in {
            opacity: 1;
            transform: scale(1);
            filter: blur(0px);
        }

        .floating-text {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100;
            font-family: 'Playfair Display', serif;
            font-size: clamp(2.5rem, 8vw, 6rem);
            font-weight: 700;
            color: #fff;
            text-align: center;
            opacity: 0;
            transition: all 1.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            pointer-events: none;
            text-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
            letter-spacing: -0.02em;
            line-height: 1.1;
        }

        .floating-text.appear {
            opacity: 1;
            transform: translate(-50%, -50%) translateY(0) scale(1);
            filter: blur(0px);
        }

        .floating-text.entering {
            opacity: 0;
            transform: translate(-50%, -50%) translateY(60px) scale(0.8);
            filter: blur(3px);
        }

        .floating-text.leaving {
            opacity: 0;
            transform: translate(-50%, -50%) translateY(-60px) scale(1.1);
            filter: blur(5px);
        }

        /* Elegant fade overlay for transitions */
        .fade-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, rgba(44, 62, 80, 0.1) 0%, rgba(230, 126, 34, 0.1) 100%);
            opacity: 0;
            transition: opacity 1.2s ease;
            z-index: 5;
        }

        .fade-overlay.active {
            opacity: 1;
        }

        /* Breathing animation for text */
        @keyframes breathe {

            0%,
            100% {
                transform: translate(-50%, -50%) scale(1);
            }

            50% {
                transform: translate(-50%, -50%) scale(1.02);
            }
        }

        .floating-text.breathing {
            animation: breathe 4s ease-in-out infinite;
        }

        /* Mobile responsiveness */
        @media (max-width: 768px) {
            .floating-text {
                font-size: clamp(2rem, 10vw, 4rem);
                padding: 0 1rem;
            }

            .products-section {
                min-height: 400vh;
            }
        }

        /* Performance optimizations */
        .products-grid {
            will-change: transform;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
        }

        .bg-layer {
            will-change: opacity, filter, transform;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
        }

        .floating-text {
            will-change: opacity, transform, filter;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
        }
    </style>
</head>

<body class="bg-brandLight font-poppins">

    <section id="products" class="products-section">
        <!-- Floating Text Elements -->
        <div id="text-1" class="floating-text entering">Where lines meet light</div>
        <div id="text-2" class="floating-text entering">and functions meet soul</div>
        <div id="text-3" class="floating-text entering">you'll find us</div>

        <!-- Products Grid with dual layer system -->
        <div id="products-grid" class="products-grid rounded-xl">
            <div class="bg-layer current" id="bg-layer-1"></div>
            <div class="bg-layer next" id="bg-layer-2"></div>
            <div class="fade-overlay" id="fade-overlay"></div>
        </div>
    </section>

    <script src="https://unpkg.com/aos@2.3.1/dist/aos.js"></script>

    <script>
        AOS.init();

        // Animation Controller
        class ScrollAnimationController {
            constructor() {
                this.productsSection = document.querySelector('.products-section');
                this.productsGrid = document.getElementById('products-grid');
                this.texts = [
                    document.getElementById('text-1'),
                    document.getElementById('text-2'),
                    document.getElementById('text-3')
                ];
                this.bgLayers = [
                    document.getElementById('bg-layer-1'),
                    document.getElementById('bg-layer-2')
                ];
                this.fadeOverlay = document.getElementById('fade-overlay');

                // Using your actual images
                this.images = [
                    '/assets/images/linemeetslight.png',
                    '/assets/images/functionmeetsoul.png',
                    '/assets/images/taglinebg.png'
                ];

                this.currentImageIndex = 0;
                this.currentLayerIndex = 0;
                this.currentTextIndex = -1;
                this.isTransitioning = false;
                this.lastScrollProgress = 0;
                this.transitionLock = false;

                this.init();
            }

            init() {
                // Set initial background
                this.bgLayers[0].style.backgroundImage = `url('${this.images[0]}')`;
                this.bgLayers[1].style.backgroundImage = `url('${this.images[1]}')`;

                // Bind scroll handler
                this.handleScroll = this.handleScroll.bind(this);
                window.addEventListener('scroll', this.handleScroll);

                // Initial update
                this.updateAnimation();
            }

            handleScroll() {
                if (!this.ticking) {
                    requestAnimationFrame(() => {
                        this.updateAnimation();
                        this.ticking = false;
                    });
                    this.ticking = true;
                }
            }

            updateAnimation() {
                const rect = this.productsSection.getBoundingClientRect();
                const sectionHeight = this.productsSection.offsetHeight;
                const viewportHeight = window.innerHeight;

                // Calculate smooth scroll progress
                const scrollProgress = Math.max(0, Math.min(1, -rect.top / (sectionHeight - viewportHeight)));

                // Prevent rapid scroll issues by checking for major jumps
                const progressDiff = Math.abs(scrollProgress - this.lastScrollProgress);
                if (progressDiff > 0.1 && this.isTransitioning) {
                    // Reset transition state if there's a major scroll jump
                    this.resetTransitionState();
                }
                this.lastScrollProgress = scrollProgress;

                // Define animation phases with smoother transitions
                const phases = [
                    { start: 0, end: 0.12, type: 'image', index: 0, blur: false },      // Image 1 clear
                    { start: 0.12, end: 0.18, type: 'blur-in', index: 0 },             // Start blur
                    { start: 0.18, end: 0.28, type: 'text', index: 0, textIndex: 0 },  // Text 1 appears
                    { start: 0.28, end: 0.35, type: 'text-out', index: 0, textIndex: 0 }, // Text 1 disappears
                    { start: 0.35, end: 0.42, type: 'transition', from: 0, to: 1 },     // Transition to image 2

                    { start: 0.42, end: 0.54, type: 'image', index: 1, blur: false },   // Image 2 clear
                    { start: 0.54, end: 0.60, type: 'blur-in', index: 1 },             // Start blur
                    { start: 0.60, end: 0.70, type: 'text', index: 1, textIndex: 1 },  // Text 2 appears
                    { start: 0.70, end: 0.77, type: 'text-out', index: 1, textIndex: 1 }, // Text 2 disappears
                    { start: 0.77, end: 0.84, type: 'transition', from: 1, to: 2 },     // Transition to image 3

                    { start: 0.84, end: 0.96, type: 'image', index: 2, blur: false },   // Image 3 clear
                    { start: 0.96, end: 1, type: 'text', index: 2, textIndex: 2 }       // Final text
                ];

                // Find current phase
                const currentPhase = phases.find(phase =>
                    scrollProgress >= phase.start && scrollProgress < phase.end
                ) || phases[phases.length - 1];

                this.executePhase(currentPhase, scrollProgress);
            }

            executePhase(phase, scrollProgress) {
                const phaseProgress = (scrollProgress - phase.start) / (phase.end - phase.start);

                switch (phase.type) {
                    case 'image':
                        this.showImage(phase.index, false);
                        this.hideAllTexts();
                        break;

                    case 'blur-in':
                        this.showImage(phase.index, true, phaseProgress);
                        break;

                    case 'text':
                        this.showImage(phase.index, true);
                        this.showText(phase.textIndex, phaseProgress);
                        break;

                    case 'text-out':
                        this.showImage(phase.index, true);
                        this.hideText(phase.textIndex, phaseProgress);
                        break;

                    case 'transition':
                        this.transitionImage(phase.from, phase.to, phaseProgress);
                        this.hideAllTexts();
                        break;
                }
            }

            showImage(index, blur = false, blurProgress = 1) {
                if (this.currentImageIndex !== index && !this.isTransitioning) {
                    this.switchToImage(index);
                }

                const currentLayer = this.bgLayers[this.currentLayerIndex];

                if (blur) {
                    const blurAmount = 15 * blurProgress;
                    const brightness = 0.7 + (0.3 * (1 - blurProgress));
                    currentLayer.style.filter = `blur(${blurAmount}px) brightness(${brightness})`;
                    currentLayer.style.transform = `scale(${1 + 0.05 * blurProgress})`;

                    this.fadeOverlay.style.opacity = blurProgress * 0.3;
                } else {
                    currentLayer.style.filter = 'blur(0px) brightness(1)';
                    currentLayer.style.transform = 'scale(1)';
                    this.fadeOverlay.style.opacity = '0';
                }
            }

            switchToImage(index) {
                if (this.isTransitioning || this.transitionLock) return;

                // Only switch if we're actually changing images
                if (this.currentImageIndex === index) return;

                this.currentImageIndex = index;
                const currentLayer = this.bgLayers[this.currentLayerIndex];

                // Set new image
                currentLayer.style.backgroundImage = `url('${this.images[index]}')`;
            }

            resetTransitionState() {
                this.isTransitioning = false;
                this.transitionLock = false;

                // Reset both layers to known states
                this.bgLayers.forEach((layer, index) => {
                    layer.style.opacity = index === this.currentLayerIndex ? '1' : '0';
                    layer.style.transform = 'scale(1)';
                    layer.style.filter = 'blur(0px)';
                });
            }

            transitionImage(fromIndex, toIndex, progress) {
                // Prevent multiple transitions and ensure proper image sequence
                if (!this.isTransitioning && !this.transitionLock) {
                    this.isTransitioning = true;
                    this.transitionLock = true;
                    this.startImageTransition(fromIndex, toIndex);
                }

                if (this.isTransitioning) {
                    this.updateImageTransition(progress);

                    if (progress >= 1) {
                        this.completeImageTransition(toIndex);
                    }
                }
            }

            startImageTransition(fromIndex, toIndex) {
                const currentLayer = this.bgLayers[this.currentLayerIndex];
                const nextLayerIndex = 1 - this.currentLayerIndex;
                const nextLayer = this.bgLayers[nextLayerIndex];

                // Setup next layer
                nextLayer.style.backgroundImage = `url('${this.images[toIndex]}')`;
                nextLayer.style.opacity = '0';
                nextLayer.style.transform = 'scale(1.1)';
                nextLayer.style.filter = 'blur(0px)';

                // Start current layer fade out with blur
                currentLayer.style.filter = 'blur(8px) brightness(0.8)';
            }

            updateImageTransition(progress) {
                const currentLayer = this.bgLayers[this.currentLayerIndex];
                const nextLayer = this.bgLayers[1 - this.currentLayerIndex];

                // Smooth easing function
                const easeProgress = this.easeInOutCubic(progress);

                // Fade out current, fade in next
                currentLayer.style.opacity = 1 - easeProgress;
                nextLayer.style.opacity = easeProgress;
                nextLayer.style.transform = `scale(${1.1 - 0.1 * easeProgress})`;

                // Add subtle blur transition
                const blurAmount = 3 * (1 - Math.abs(0.5 - easeProgress) * 2);
                nextLayer.style.filter = `blur(${blurAmount}px)`;
            }

            completeImageTransition(toIndex) {
                const nextLayerIndex = 1 - this.currentLayerIndex;
                const nextLayer = this.bgLayers[nextLayerIndex];
                const currentLayer = this.bgLayers[this.currentLayerIndex];

                // Finalize transition
                nextLayer.style.opacity = '1';
                nextLayer.style.transform = 'scale(1)';
                nextLayer.style.filter = 'blur(0px)';

                // Hide previous layer
                currentLayer.style.opacity = '0';

                // Switch active layer
                this.currentLayerIndex = nextLayerIndex;
                this.currentImageIndex = toIndex;
                this.isTransitioning = false;

                // Add small delay before allowing next transition
                setTimeout(() => {
                    this.transitionLock = false;
                }, 100);
            }

            showText(index, progress) {
                const text = this.texts[index];
                const easeProgress = this.easeOutCubic(progress);

                if (this.currentTextIndex !== index) {
                    this.hideAllTexts();
                    this.currentTextIndex = index;
                }

                text.classList.remove('entering', 'leaving');
                text.classList.add('appear', 'breathing');
                text.style.opacity = easeProgress;
                text.style.transform = `translate(-50%, -50%) translateY(${60 * (1 - easeProgress)}px) scale(${0.8 + 0.2 * easeProgress})`;
                text.style.filter = `blur(${3 * (1 - easeProgress)}px)`;
            }

            hideText(index, progress) {
                const text = this.texts[index];
                const easeProgress = this.easeInCubic(progress);

                text.classList.remove('appear', 'breathing');
                text.classList.add('leaving');
                text.style.opacity = 1 - easeProgress;
                text.style.transform = `translate(-50%, -50%) translateY(${-60 * easeProgress}px) scale(${1 + 0.1 * easeProgress})`;
                text.style.filter = `blur(${5 * easeProgress}px)`;
            }

            hideAllTexts() {
                this.texts.forEach(text => {
                    text.classList.remove('appear', 'breathing');
                    text.classList.add('entering');
                    text.style.opacity = '0';
                });
                this.currentTextIndex = -1;
            }

            // Easing functions
            easeInOutCubic(t) {
                return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
            }

            easeOutCubic(t) {
                return 1 - Math.pow(1 - t, 3);
            }

            easeInCubic(t) {
                return t * t * t;
            }
        }

        // Initialize animation controller
        document.addEventListener('DOMContentLoaded', () => {
            new ScrollAnimationController();
        });

    </script>
</body>

</html>